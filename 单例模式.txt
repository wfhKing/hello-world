	Java中单例模式是确保某一个类只有一个实例,而且自行实例化并向整个系统提供这个实例，
在计算机中，线程池、缓存、日志对象、对话框、打印机、显卡的驱动程序对象常被设计成单例的模式。


	Java单例模式分成三种：
		（1）懒汉式单例:类加载的时候实例化对象（比较饿，主动实例化对象）
			1.实现单例就去改写构造方法:将构造方法改写为私有的，改写之后，就不
			能直接实例化了(不允许外部直接参加实例)
			2.参加类的唯一实例(类里面去new一个实例,且这个实例是static[变量、
			方法加static厚就变成类所有，不是必有参加实例对象来调用]，这样就可以
			通过类直接调用这个实例[类名，实例变量名])
			3.为了安全，不允许外部直接访问成员变量，所有(2)需要优化，将类的static
			实例变成private，变为private之后就不能直接通过"类名.实例变量名"来
			访问了，所有提供累的方法get，类的get方法有需要时static才能通过"
			类名.方法"调用
		（2）饿汉式单例:类加载的时候只有声明一下，调用这个单例的时候才实例化(比较懒，不主动去实例对象)
			1.先声明一个单例，并不实例化单例对象
			2.在get方法里面去判断,如果没有实例这个对象，就讲单例对象实例化再返回
		（3）登记式单例


	Java单例模式的特点:
		（1）单例类只能有一个实例
		（2）单例类必须自己曾经自己的唯一实例
		（3）单例类必须给所有其他对象提供这一实例


	构建单例模式的关键:
		（1）构造函数不对外开放，一般为private修饰
		（2）通过一个静态方法或枚举返回单例类对象
		（3）确保单例类的对象有且只有一个，尤其是多线程的环境下
		（4）确保单例类对象在反序列化时不会出现构建对象


	对比：
		1.饿汉式是线程安全的,在类创建的同时就已经创建好一个静态的对象供系统使用,
		以后不在改变。懒汉式如果在创建实例对象时不加上synchronized则会导致对对象
		的访问不是线程安全的。 
		2.从实现方式来讲他们最大的区别就是懒汉式是延时加载,他是在需要的时候才创建
		对象,而饿汉式在虚拟机启动的时候就会创建，饿汉式无需关注多线程问题、写法简
		单明了、能用则用。但是它是加载类时创建实例、所以如果
		是一个工厂模式、缓存了很多实例、那么就得考虑效率问题，因为这个类一加载则把
		所有实例不管用不用一块创建。
		懒汉模式：类加载快，获取对象慢，线程安全的
		饿汉模式：类加载慢，获取对象快，线程不安全

		
		